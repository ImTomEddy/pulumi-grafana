// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.grafana.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.grafana.outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth;
import com.pulumi.grafana.outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp;
import com.pulumi.grafana.outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp;
import com.pulumi.grafana.outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class SyntheticMonitoringCheckSettingsHttp {
    /**
     * @return Basic auth settings.
     * 
     */
    private @Nullable SyntheticMonitoringCheckSettingsHttpBasicAuth basicAuth;
    /**
     * @return Token for use with bearer authorization header.
     * 
     */
    private @Nullable String bearerToken;
    /**
     * @return The body of the HTTP request used in probe.
     * 
     */
    private @Nullable String body;
    /**
     * @return The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
     * 
     */
    private @Nullable String cacheBustingQueryParamName;
    /**
     * @return List of regexes. If any match the response body, the check will fail.
     * 
     */
    private @Nullable List<String> failIfBodyMatchesRegexps;
    /**
     * @return List of regexes. If any do not match the response body, the check will fail.
     * 
     */
    private @Nullable List<String> failIfBodyNotMatchesRegexps;
    /**
     * @return Check fails if headers match.
     * 
     */
    private @Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp> failIfHeaderMatchesRegexps;
    /**
     * @return Check fails if headers do not match.
     * 
     */
    private @Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp> failIfHeaderNotMatchesRegexps;
    /**
     * @return Fail if SSL is not present. Defaults to `false`.
     * 
     */
    private @Nullable Boolean failIfNotSsl;
    /**
     * @return Fail if SSL is present. Defaults to `false`.
     * 
     */
    private @Nullable Boolean failIfSsl;
    /**
     * @return The HTTP headers set for the probe.
     * 
     */
    private @Nullable List<String> headers;
    /**
     * @return Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that&#39;s not available. Defaults to `V4`.
     * 
     */
    private @Nullable String ipVersion;
    /**
     * @return Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
     * 
     */
    private @Nullable String method;
    /**
     * @return Do not follow redirects. Defaults to `false`.
     * 
     */
    private @Nullable Boolean noFollowRedirects;
    /**
     * @return Proxy URL.
     * 
     */
    private @Nullable String proxyUrl;
    /**
     * @return TLS config.
     * 
     */
    private @Nullable SyntheticMonitoringCheckSettingsHttpTlsConfig tlsConfig;
    /**
     * @return List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
     * 
     */
    private @Nullable List<String> validHttpVersions;
    /**
     * @return Accepted status codes. If unset, defaults to 2xx.
     * 
     */
    private @Nullable List<Integer> validStatusCodes;

    private SyntheticMonitoringCheckSettingsHttp() {}
    /**
     * @return Basic auth settings.
     * 
     */
    public Optional<SyntheticMonitoringCheckSettingsHttpBasicAuth> basicAuth() {
        return Optional.ofNullable(this.basicAuth);
    }
    /**
     * @return Token for use with bearer authorization header.
     * 
     */
    public Optional<String> bearerToken() {
        return Optional.ofNullable(this.bearerToken);
    }
    /**
     * @return The body of the HTTP request used in probe.
     * 
     */
    public Optional<String> body() {
        return Optional.ofNullable(this.body);
    }
    /**
     * @return The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.
     * 
     */
    public Optional<String> cacheBustingQueryParamName() {
        return Optional.ofNullable(this.cacheBustingQueryParamName);
    }
    /**
     * @return List of regexes. If any match the response body, the check will fail.
     * 
     */
    public List<String> failIfBodyMatchesRegexps() {
        return this.failIfBodyMatchesRegexps == null ? List.of() : this.failIfBodyMatchesRegexps;
    }
    /**
     * @return List of regexes. If any do not match the response body, the check will fail.
     * 
     */
    public List<String> failIfBodyNotMatchesRegexps() {
        return this.failIfBodyNotMatchesRegexps == null ? List.of() : this.failIfBodyNotMatchesRegexps;
    }
    /**
     * @return Check fails if headers match.
     * 
     */
    public List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp> failIfHeaderMatchesRegexps() {
        return this.failIfHeaderMatchesRegexps == null ? List.of() : this.failIfHeaderMatchesRegexps;
    }
    /**
     * @return Check fails if headers do not match.
     * 
     */
    public List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp> failIfHeaderNotMatchesRegexps() {
        return this.failIfHeaderNotMatchesRegexps == null ? List.of() : this.failIfHeaderNotMatchesRegexps;
    }
    /**
     * @return Fail if SSL is not present. Defaults to `false`.
     * 
     */
    public Optional<Boolean> failIfNotSsl() {
        return Optional.ofNullable(this.failIfNotSsl);
    }
    /**
     * @return Fail if SSL is present. Defaults to `false`.
     * 
     */
    public Optional<Boolean> failIfSsl() {
        return Optional.ofNullable(this.failIfSsl);
    }
    /**
     * @return The HTTP headers set for the probe.
     * 
     */
    public List<String> headers() {
        return this.headers == null ? List.of() : this.headers;
    }
    /**
     * @return Options are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that&#39;s not available. Defaults to `V4`.
     * 
     */
    public Optional<String> ipVersion() {
        return Optional.ofNullable(this.ipVersion);
    }
    /**
     * @return Request method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.
     * 
     */
    public Optional<String> method() {
        return Optional.ofNullable(this.method);
    }
    /**
     * @return Do not follow redirects. Defaults to `false`.
     * 
     */
    public Optional<Boolean> noFollowRedirects() {
        return Optional.ofNullable(this.noFollowRedirects);
    }
    /**
     * @return Proxy URL.
     * 
     */
    public Optional<String> proxyUrl() {
        return Optional.ofNullable(this.proxyUrl);
    }
    /**
     * @return TLS config.
     * 
     */
    public Optional<SyntheticMonitoringCheckSettingsHttpTlsConfig> tlsConfig() {
        return Optional.ofNullable(this.tlsConfig);
    }
    /**
     * @return List of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`
     * 
     */
    public List<String> validHttpVersions() {
        return this.validHttpVersions == null ? List.of() : this.validHttpVersions;
    }
    /**
     * @return Accepted status codes. If unset, defaults to 2xx.
     * 
     */
    public List<Integer> validStatusCodes() {
        return this.validStatusCodes == null ? List.of() : this.validStatusCodes;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(SyntheticMonitoringCheckSettingsHttp defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable SyntheticMonitoringCheckSettingsHttpBasicAuth basicAuth;
        private @Nullable String bearerToken;
        private @Nullable String body;
        private @Nullable String cacheBustingQueryParamName;
        private @Nullable List<String> failIfBodyMatchesRegexps;
        private @Nullable List<String> failIfBodyNotMatchesRegexps;
        private @Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp> failIfHeaderMatchesRegexps;
        private @Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp> failIfHeaderNotMatchesRegexps;
        private @Nullable Boolean failIfNotSsl;
        private @Nullable Boolean failIfSsl;
        private @Nullable List<String> headers;
        private @Nullable String ipVersion;
        private @Nullable String method;
        private @Nullable Boolean noFollowRedirects;
        private @Nullable String proxyUrl;
        private @Nullable SyntheticMonitoringCheckSettingsHttpTlsConfig tlsConfig;
        private @Nullable List<String> validHttpVersions;
        private @Nullable List<Integer> validStatusCodes;
        public Builder() {}
        public Builder(SyntheticMonitoringCheckSettingsHttp defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.basicAuth = defaults.basicAuth;
    	      this.bearerToken = defaults.bearerToken;
    	      this.body = defaults.body;
    	      this.cacheBustingQueryParamName = defaults.cacheBustingQueryParamName;
    	      this.failIfBodyMatchesRegexps = defaults.failIfBodyMatchesRegexps;
    	      this.failIfBodyNotMatchesRegexps = defaults.failIfBodyNotMatchesRegexps;
    	      this.failIfHeaderMatchesRegexps = defaults.failIfHeaderMatchesRegexps;
    	      this.failIfHeaderNotMatchesRegexps = defaults.failIfHeaderNotMatchesRegexps;
    	      this.failIfNotSsl = defaults.failIfNotSsl;
    	      this.failIfSsl = defaults.failIfSsl;
    	      this.headers = defaults.headers;
    	      this.ipVersion = defaults.ipVersion;
    	      this.method = defaults.method;
    	      this.noFollowRedirects = defaults.noFollowRedirects;
    	      this.proxyUrl = defaults.proxyUrl;
    	      this.tlsConfig = defaults.tlsConfig;
    	      this.validHttpVersions = defaults.validHttpVersions;
    	      this.validStatusCodes = defaults.validStatusCodes;
        }

        @CustomType.Setter
        public Builder basicAuth(@Nullable SyntheticMonitoringCheckSettingsHttpBasicAuth basicAuth) {
            this.basicAuth = basicAuth;
            return this;
        }
        @CustomType.Setter
        public Builder bearerToken(@Nullable String bearerToken) {
            this.bearerToken = bearerToken;
            return this;
        }
        @CustomType.Setter
        public Builder body(@Nullable String body) {
            this.body = body;
            return this;
        }
        @CustomType.Setter
        public Builder cacheBustingQueryParamName(@Nullable String cacheBustingQueryParamName) {
            this.cacheBustingQueryParamName = cacheBustingQueryParamName;
            return this;
        }
        @CustomType.Setter
        public Builder failIfBodyMatchesRegexps(@Nullable List<String> failIfBodyMatchesRegexps) {
            this.failIfBodyMatchesRegexps = failIfBodyMatchesRegexps;
            return this;
        }
        public Builder failIfBodyMatchesRegexps(String... failIfBodyMatchesRegexps) {
            return failIfBodyMatchesRegexps(List.of(failIfBodyMatchesRegexps));
        }
        @CustomType.Setter
        public Builder failIfBodyNotMatchesRegexps(@Nullable List<String> failIfBodyNotMatchesRegexps) {
            this.failIfBodyNotMatchesRegexps = failIfBodyNotMatchesRegexps;
            return this;
        }
        public Builder failIfBodyNotMatchesRegexps(String... failIfBodyNotMatchesRegexps) {
            return failIfBodyNotMatchesRegexps(List.of(failIfBodyNotMatchesRegexps));
        }
        @CustomType.Setter
        public Builder failIfHeaderMatchesRegexps(@Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp> failIfHeaderMatchesRegexps) {
            this.failIfHeaderMatchesRegexps = failIfHeaderMatchesRegexps;
            return this;
        }
        public Builder failIfHeaderMatchesRegexps(SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp... failIfHeaderMatchesRegexps) {
            return failIfHeaderMatchesRegexps(List.of(failIfHeaderMatchesRegexps));
        }
        @CustomType.Setter
        public Builder failIfHeaderNotMatchesRegexps(@Nullable List<SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp> failIfHeaderNotMatchesRegexps) {
            this.failIfHeaderNotMatchesRegexps = failIfHeaderNotMatchesRegexps;
            return this;
        }
        public Builder failIfHeaderNotMatchesRegexps(SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp... failIfHeaderNotMatchesRegexps) {
            return failIfHeaderNotMatchesRegexps(List.of(failIfHeaderNotMatchesRegexps));
        }
        @CustomType.Setter
        public Builder failIfNotSsl(@Nullable Boolean failIfNotSsl) {
            this.failIfNotSsl = failIfNotSsl;
            return this;
        }
        @CustomType.Setter
        public Builder failIfSsl(@Nullable Boolean failIfSsl) {
            this.failIfSsl = failIfSsl;
            return this;
        }
        @CustomType.Setter
        public Builder headers(@Nullable List<String> headers) {
            this.headers = headers;
            return this;
        }
        public Builder headers(String... headers) {
            return headers(List.of(headers));
        }
        @CustomType.Setter
        public Builder ipVersion(@Nullable String ipVersion) {
            this.ipVersion = ipVersion;
            return this;
        }
        @CustomType.Setter
        public Builder method(@Nullable String method) {
            this.method = method;
            return this;
        }
        @CustomType.Setter
        public Builder noFollowRedirects(@Nullable Boolean noFollowRedirects) {
            this.noFollowRedirects = noFollowRedirects;
            return this;
        }
        @CustomType.Setter
        public Builder proxyUrl(@Nullable String proxyUrl) {
            this.proxyUrl = proxyUrl;
            return this;
        }
        @CustomType.Setter
        public Builder tlsConfig(@Nullable SyntheticMonitoringCheckSettingsHttpTlsConfig tlsConfig) {
            this.tlsConfig = tlsConfig;
            return this;
        }
        @CustomType.Setter
        public Builder validHttpVersions(@Nullable List<String> validHttpVersions) {
            this.validHttpVersions = validHttpVersions;
            return this;
        }
        public Builder validHttpVersions(String... validHttpVersions) {
            return validHttpVersions(List.of(validHttpVersions));
        }
        @CustomType.Setter
        public Builder validStatusCodes(@Nullable List<Integer> validStatusCodes) {
            this.validStatusCodes = validStatusCodes;
            return this;
        }
        public Builder validStatusCodes(Integer... validStatusCodes) {
            return validStatusCodes(List.of(validStatusCodes));
        }
        public SyntheticMonitoringCheckSettingsHttp build() {
            final var o = new SyntheticMonitoringCheckSettingsHttp();
            o.basicAuth = basicAuth;
            o.bearerToken = bearerToken;
            o.body = body;
            o.cacheBustingQueryParamName = cacheBustingQueryParamName;
            o.failIfBodyMatchesRegexps = failIfBodyMatchesRegexps;
            o.failIfBodyNotMatchesRegexps = failIfBodyNotMatchesRegexps;
            o.failIfHeaderMatchesRegexps = failIfHeaderMatchesRegexps;
            o.failIfHeaderNotMatchesRegexps = failIfHeaderNotMatchesRegexps;
            o.failIfNotSsl = failIfNotSsl;
            o.failIfSsl = failIfSsl;
            o.headers = headers;
            o.ipVersion = ipVersion;
            o.method = method;
            o.noFollowRedirects = noFollowRedirects;
            o.proxyUrl = proxyUrl;
            o.tlsConfig = tlsConfig;
            o.validHttpVersions = validHttpVersions;
            o.validStatusCodes = validStatusCodes;
            return o;
        }
    }
}
