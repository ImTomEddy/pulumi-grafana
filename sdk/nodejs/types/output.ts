// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface BuiltinRoleAssignmentRole {
    /**
     * States whether the assignment is available across all organizations or not. Defaults to `false`.
     */
    global?: boolean;
    /**
     * Unique identifier of the role to assign to `builtinRole`.
     */
    uid: string;
}

export interface ContactPointAlertmanager {
    /**
     * The password component of the basic auth credentials to use.
     */
    basicAuthPassword?: string;
    /**
     * The username component of the basic auth credentials to use.
     */
    basicAuthUser?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL of the Alertmanager instance.
     */
    url: string;
}

export interface ContactPointDingding {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * The format of message to send - either 'link' or 'actionCard'
     */
    messageType?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The DingDing webhook URL.
     */
    url: string;
}

export interface ContactPointDiscord {
    /**
     * The URL of a custom avatar image to use. Defaults to ``.
     */
    avatarUrl?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message. Defaults to ``.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The discord webhook URL.
     */
    url: string;
    /**
     * Whether to use the bot account's plain username instead of "Grafana." Defaults to `false`.
     */
    useDiscordUsername?: boolean;
}

export interface ContactPointEmail {
    /**
     * The addresses to send emails to.
     */
    addresses: string[];
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the email. Defaults to ``.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.
     */
    singleEmail?: boolean;
    /**
     * The templated subject line of the email. Defaults to ``.
     */
    subject?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointGooglechat {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The Google Chat webhook URL.
     */
    url: string;
}

export interface ContactPointKafka {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The URL of the Kafka REST proxy to send requests to.
     */
    restProxyUrl: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The name of the Kafka topic to publish to.
     */
    topic: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointOpsgeny {
    /**
     * The OpsGenie API key to use.
     */
    apiKey: string;
    /**
     * Whether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.
     */
    autoClose?: boolean;
    /**
     * A templated high-level description to use for the alert.
     */
    description?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * Whether to allow the alert priority to be configured via the value of the `ogPriority` annotation on the alert.
     */
    overridePriority?: boolean;
    /**
     * Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.
     */
    sendTagsAs?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * Allows customization of the OpsGenie API URL.
     */
    url?: string;
}

export interface ContactPointPagerduty {
    /**
     * The class or type of event, for example `ping failure`.
     */
    class?: string;
    /**
     * The component being affected by the event.
     */
    component?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The group to which the provided component belongs to.
     */
    group?: string;
    /**
     * The PagerDuty API key.
     */
    integrationKey: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The PagerDuty event severity level. Default is `critical`.
     */
    severity?: string;
    /**
     * The templated summary message of the event.
     */
    summary?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointPushover {
    /**
     * The Pushover API token.
     */
    apiToken: string;
    /**
     * Comma-separated list of devices to which the event is associated.
     */
    device?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * How many seconds for which the notification will continue to be retried by Pushover.
     */
    expire?: number;
    /**
     * The templated notification message content.
     */
    message?: string;
    /**
     * The priority level of the resolved event.
     */
    okPriority?: number;
    /**
     * The sound associated with the resolved notification.
     */
    okSound?: string;
    /**
     * The priority level of the event.
     */
    priority?: number;
    /**
     * How often, in seconds, the Pushover servers will send the same notification to the user.
     */
    retry?: number;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The sound associated with the notification.
     */
    sound?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The Pushover user key.
     */
    userKey: string;
}

export interface ContactPointSensugo {
    /**
     * The SensuGo API key.
     */
    apiKey: string;
    /**
     * The SensuGo check to which the event should be routed.
     */
    check?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The entity being monitored.
     */
    entity?: string;
    /**
     * A custom handler to execute in addition to the check.
     */
    handler?: string;
    /**
     * Templated message content describing the alert.
     */
    message?: string;
    /**
     * The namespace in which the check resides.
     */
    namespace?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The SensuGo URL to send requests to.
     */
    url: string;
}

export interface ContactPointSlack {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * Use this to override the Slack API endpoint URL to send requests to.
     */
    endpointUrl?: string;
    /**
     * The name of a Slack workspace emoji to use as the bot icon.
     */
    iconEmoji?: string;
    /**
     * A URL of an image to use as the bot icon.
     */
    iconUrl?: string;
    /**
     * Describes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.
     */
    mentionChannel?: string;
    /**
     * Comma-separated list of groups to mention in the message.
     */
    mentionGroups?: string;
    /**
     * Comma-separated list of users to mention in the message.
     */
    mentionUsers?: string;
    /**
     * Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.
     */
    recipient?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * Templated content of the message.
     */
    text?: string;
    /**
     * Templated title of the message.
     */
    title?: string;
    /**
     * A Slack API token,for sending messages directly without the webhook method.
     */
    token?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * A Slack webhook URL,for sending messages via the webhook method.
     */
    url?: string;
    /**
     * Username for the bot to use.
     */
    username?: string;
}

export interface ContactPointTeam {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated message content to send.
     */
    message?: string;
    /**
     * The templated subtitle for each message section.
     */
    sectionTitle?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * A Teams webhook URL.
     */
    url: string;
}

export interface ContactPointTelegram {
    /**
     * The chat ID to send messages to.
     */
    chatId: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The Telegram bot token.
     */
    token: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointThreema {
    /**
     * The Threema API key.
     */
    apiSecret: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The Threema gateway ID.
     */
    gatewayId: string;
    /**
     * The ID of the recipient of the message.
     */
    recipientId: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
}

export interface ContactPointVictorop {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.
     */
    messageType?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The VictorOps webhook URL.
     */
    url: string;
}

export interface ContactPointWebhook {
    /**
     * Allows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.
     */
    authorizationCredentials?: string;
    /**
     * Allows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.
     */
    authorizationScheme?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthPassword?: string;
    /**
     * The username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.
     */
    basicAuthUser?: string;
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The HTTP method to use in the request. Defaults to `POST`.
     */
    httpMethod?: string;
    /**
     * The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.
     */
    maxAlerts?: number;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The URL to send webhook requests to.
     */
    url: string;
}

export interface ContactPointWecom {
    /**
     * Whether to disable sending resolve messages. Defaults to `false`.
     */
    disableResolveMessage?: boolean;
    /**
     * The templated content of the message to send.
     */
    message?: string;
    /**
     * Additional custom properties to attach to the notifier. Defaults to `map[]`.
     */
    settings?: {[key: string]: string};
    /**
     * The templated title of the message to send.
     */
    title?: string;
    /**
     * The UID of the contact point.
     */
    uid: string;
    /**
     * The WeCom webhook URL.
     */
    url: string;
}

export interface DashboardPermissionPermission {
    /**
     * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
     */
    permission: string;
    /**
     * Manage permissions for `Viewer` or `Editor` roles.
     */
    role?: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: number;
    /**
     * ID of the user to manage permissions for. Defaults to `0`.
     */
    userId?: number;
}

export interface DataSourceJsonData {
    /**
     * (CloudWatch, Athena) The ARN of the role to be assumed by Grafana when using the CloudWatch or Athena data source.
     */
    assumeRoleArn?: string;
    /**
     * (CloudWatch, Athena) The authentication type used to access the data source.
     */
    authType?: string;
    /**
     * (Stackdriver) The authentication type: `jwt` or `gce`.
     */
    authenticationType?: string;
    /**
     * (Athena) Athena catalog.
     */
    catalog?: string;
    /**
     * (Stackdriver) Service account email address.
     */
    clientEmail?: string;
    /**
     * (Azure Monitor) The service account client id.
     */
    clientId?: string;
    /**
     * (Azure Monitor) The cloud name.
     */
    cloudName?: string;
    /**
     * (MySQL, PostgreSQL, and MSSQL) Maximum amount of time in seconds a connection may be reused (Grafana v5.4+).
     */
    connMaxLifetime?: number;
    /**
     * (CloudWatch) A comma-separated list of custom namespaces to be queried by the CloudWatch data source.
     */
    customMetricsNamespaces?: string;
    /**
     * (Athena) Name of the database within the catalog.
     */
    database?: string;
    /**
     * (InfluxDB) The default bucket for the data source.
     */
    defaultBucket?: string;
    /**
     * (Stackdriver) The default project for the data source.
     */
    defaultProject?: string;
    /**
     * (CloudWatch, Athena) The default region for the data source.
     */
    defaultRegion?: string;
    /**
     * (Loki) See https://grafana.com/docs/grafana/latest/datasources/loki/#derived-fields
     */
    derivedFields?: outputs.DataSourceJsonDataDerivedField[];
    /**
     * (MSSQL) Connection SSL encryption handling: 'disable', 'false' or 'true'.
     */
    encrypt?: string;
    /**
     * (Elasticsearch) Elasticsearch semantic version (Grafana v8.0+).
     */
    esVersion?: string;
    /**
     * (CloudWatch, Athena) If you are assuming a role in another account, that has been created with an external ID, specify the external ID here.
     */
    externalId?: string;
    /**
     * (Github) Github URL
     */
    githubUrl?: string;
    /**
     * (Graphite) Graphite version.
     */
    graphiteVersion?: string;
    /**
     * (Prometheus) HTTP method to use for making requests.
     */
    httpMethod?: string;
    /**
     * (Alertmanager) Implementation of Alertmanager. Either 'cortex' or 'prometheus'
     */
    implementation?: string;
    /**
     * (Elasticsearch) Index date time format. nil(No Pattern), 'Hourly', 'Daily', 'Weekly', 'Monthly' or 'Yearly'.
     */
    interval?: string;
    /**
     * (Elasticsearch) Which field should be used to indicate the priority of the log message.
     */
    logLevelField?: string;
    /**
     * (Elasticsearch) Which field should be used as the log message.
     */
    logMessageField?: string;
    /**
     * (Prometheus) Manage alerts.
     */
    manageAlerts?: boolean;
    /**
     * (Elasticsearch) Maximum number of concurrent shard requests.
     */
    maxConcurrentShardRequests?: number;
    /**
     * (MySQL, PostgreSQL and MSSQL) Maximum number of connections in the idle connection pool (Grafana v5.4+).
     */
    maxIdleConns?: number;
    /**
     * (Loki) Upper limit for the number of log lines returned by Loki
     */
    maxLines?: number;
    /**
     * (MySQL, PostgreSQL and MSSQL) Maximum number of open connections to the database (Grafana v5.4+).
     */
    maxOpenConns?: number;
    /**
     * (Sentry) Organization slug.
     */
    orgSlug?: string;
    /**
     * (InfluxDB) An organization is a workspace for a group of users. All dashboards, tasks, buckets, members, etc., belong to an organization.
     */
    organization?: string;
    /**
     * (Athena) AWS S3 bucket to store execution outputs. If not specified, the default query result location from the Workgroup configuration will be used.
     */
    outputLocation?: string;
    /**
     * (PostgreSQL) Postgres version as a number (903/904/905/906/1000) meaning v9.3, v9.4, etc.
     */
    postgresVersion?: number;
    /**
     * (CloudWatch, Athena) The credentials profile name to use when authentication type is set as 'Credentials file'.
     */
    profile?: string;
    /**
     * (Prometheus) Timeout for queries made to the Prometheus data source in seconds.
     */
    queryTimeout?: string;
    /**
     * (Elasticsearch and Prometheus) Specifies the ARN of an IAM role to assume.
     */
    sigv4AssumeRoleArn?: string;
    /**
     * (Elasticsearch and Prometheus) Enable usage of SigV4.
     */
    sigv4Auth?: boolean;
    /**
     * (Elasticsearch and Prometheus) The Sigv4 authentication provider to use: 'default', 'credentials' or 'keys' (AMG: 'workspace-iam-role').
     */
    sigv4AuthType?: string;
    /**
     * (Elasticsearch and Prometheus) When assuming a role in another account use this external ID.
     */
    sigv4ExternalId?: string;
    /**
     * (Elasticsearch and Prometheus) Credentials profile name, leave blank for default.
     */
    sigv4Profile?: string;
    /**
     * (Elasticsearch and Prometheus) AWS region to use for Sigv4.
     */
    sigv4Region?: string;
    /**
     * (PostgreSQL) SSLmode. 'disable', 'require', 'verify-ca' or 'verify-full'.
     */
    sslMode?: string;
    /**
     * (Azure Monitor) The subscription id
     */
    subscriptionId?: string;
    /**
     * (Azure Monitor) Service account tenant ID.
     */
    tenantId?: string;
    /**
     * (Elasticsearch) Which field that should be used as timestamp.
     */
    timeField?: string;
    /**
     * (Prometheus, Elasticsearch, InfluxDB, MySQL, PostgreSQL, and MSSQL) Lowest interval/step value that should be used for this data source. Sometimes called "Scrape Interval" in the Grafana UI.
     */
    timeInterval?: string;
    /**
     * (PostgreSQL) Enable usage of TimescaleDB extension.
     */
    timescaledb?: boolean;
    /**
     * (All) Enable TLS authentication using client cert configured in secure json data.
     */
    tlsAuth?: boolean;
    /**
     * (All) Enable TLS authentication using CA cert.
     */
    tlsAuthWithCaCert?: boolean;
    /**
     * (All) SSL Certificate configuration, either by ‘file-path’ or ‘file-content’.
     */
    tlsConfigurationMethod?: string;
    /**
     * (All) Controls whether a client verifies the server’s certificate chain and host name.
     */
    tlsSkipVerify?: boolean;
    /**
     * (Stackdriver) The token URI used, provided in the service account key.
     */
    tokenUri?: string;
    /**
     * (Cloudwatch) The X-Ray datasource uid to associate to this Cloudwatch datasource.
     */
    tracingDatasourceUid?: string;
    /**
     * (OpenTSDB) Resolution.
     */
    tsdbResolution?: number;
    /**
     * (OpenTSDB) Version.
     */
    tsdbVersion?: number;
    /**
     * (InfluxDB) InfluxQL or Flux.
     */
    version?: string;
    /**
     * (Athena) Workgroup to use.
     */
    workgroup?: string;
    /**
     * (Elasticsearch) Enable X-Pack support.
     */
    xpackEnabled?: boolean;
}

export interface DataSourceJsonDataDerivedField {
    datasourceUid?: string;
    matcherRegex?: string;
    /**
     * A unique name for the data source.
     */
    name?: string;
    /**
     * The URL for the data source. The type of URL required varies depending on the chosen data source type.
     */
    url?: string;
}

export interface DataSourcePermissionPermission {
    /**
     * Permission to associate with item. Must be `Query`.
     */
    permission: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: number;
    /**
     * ID of the user to manage permissions for. Defaults to `0`.
     */
    userId?: number;
}

export interface DataSourceSecureJsonData {
    /**
     * (CloudWatch, Athena) The access key used to access the data source.
     */
    accessKey?: string;
    /**
     * (Github) The access token used to access the data source.
     */
    accessToken?: string;
    /**
     * (Sentry) Authorization token.
     */
    authToken?: string;
    /**
     * (All) Password to use for basic authentication.
     */
    basicAuthPassword?: string;
    /**
     * (Azure Monitor) Client secret for authentication.
     */
    clientSecret?: string;
    /**
     * (All) Password to use for authentication.
     */
    password?: string;
    /**
     * (Stackdriver) The service account key `privateKey` to use to access the data source.
     */
    privateKey?: string;
    /**
     * (CloudWatch, Athena) The secret key to use to access the data source.
     */
    secretKey?: string;
    /**
     * (Elasticsearch and Prometheus) SigV4 access key. Required when using 'keys' auth provider.
     */
    sigv4AccessKey?: string;
    /**
     * (Elasticsearch and Prometheus) SigV4 secret key. Required when using 'keys' auth provider.
     */
    sigv4SecretKey?: string;
    /**
     * (All) CA cert for out going requests.
     */
    tlsCaCert?: string;
    /**
     * (All) TLS Client cert for outgoing requests.
     */
    tlsClientCert?: string;
    /**
     * (All) TLS Client key for outgoing requests.
     */
    tlsClientKey?: string;
}

export interface FolderPermissionPermission {
    /**
     * Permission to associate with item. Must be one of `View`, `Edit`, or `Admin`.
     */
    permission: string;
    /**
     * Manage permissions for `Viewer` or `Editor` roles.
     */
    role?: string;
    /**
     * ID of the team to manage permissions for. Defaults to `0`.
     */
    teamId?: number;
    /**
     * ID of the user to manage permissions for. Defaults to `0`.
     */
    userId?: number;
}

export interface GetDashboardsDashboard {
    folderTitle: string;
    title: string;
    uid: string;
}

export interface GetFoldersFolder {
    /**
     * The ID of this resource.
     */
    id: number;
    title: string;
    uid: string;
    url: string;
}

export interface MuteTimingInterval {
    /**
     * An inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".
     */
    daysOfMonths?: string[];
    /**
     * An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".
     */
    months?: string[];
    /**
     * The time ranges, represented in minutes, during which to mute in a given day.
     */
    times?: outputs.MuteTimingIntervalTime[];
    /**
     * An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".
     */
    weekdays?: string[];
    /**
     * A positive inclusive range of years, e.g. "2030" or "2025:2026".
     */
    years?: string[];
}

export interface MuteTimingIntervalTime {
    end: string;
    start: string;
}

export interface NotificationPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
     */
    groupBies: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyMatcher {
    label: string;
    match: string;
    value: string;
}

export interface NotificationPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
     */
    groupBies: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyMatcher {
    label: string;
    match: string;
    value: string;
}

export interface NotificationPolicyPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
     */
    groupBies: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Routing rules for specific label sets.
     */
    policies?: outputs.NotificationPolicyPolicyPolicyPolicyPolicy[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyPolicyMatcher {
    label: string;
    match: string;
    value: string;
}

export interface NotificationPolicyPolicyPolicyPolicyPolicy {
    /**
     * The contact point to route notifications that match this rule to.
     */
    contactPoint: string;
    /**
     * Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
     */
    continue?: boolean;
    /**
     * A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
     */
    groupBies: string[];
    /**
     * Minimum time interval between two notifications for the same group. Default is 5 minutes.
     */
    groupInterval?: string;
    /**
     * Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
     */
    groupWait?: string;
    /**
     * Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
     */
    matchers?: outputs.NotificationPolicyPolicyPolicyPolicyPolicyMatcher[];
    /**
     * A list of mute timing names to apply to alerts that match this policy.
     */
    muteTimings?: string[];
    /**
     * Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
     */
    repeatInterval?: string;
}

export interface NotificationPolicyPolicyPolicyPolicyPolicyMatcher {
    label: string;
    match: string;
    value: string;
}

export interface OncallIntegrationDefaultRoute {
    /**
     * The ID of the escalation chain.
     */
    escalationChainId?: string;
    /**
     * The ID of this resource.
     */
    id: string;
    /**
     * MS teams-specific settings for a route.
     */
    msteams?: outputs.OncallIntegrationDefaultRouteMsteams;
    /**
     * Slack-specific settings for a route.
     */
    slack?: outputs.OncallIntegrationDefaultRouteSlack;
    /**
     * Telegram-specific settings for a route.
     */
    telegram?: outputs.OncallIntegrationDefaultRouteTelegram;
}

export interface OncallIntegrationDefaultRouteMsteams {
    enabled?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
}

export interface OncallIntegrationDefaultRouteSlack {
    channelId?: string;
    enabled?: boolean;
}

export interface OncallIntegrationDefaultRouteTelegram {
    enabled?: boolean;
    /**
     * The ID of this resource.
     */
    id?: string;
}

export interface OncallIntegrationTemplates {
    /**
     * Template for the key by which alerts are grouped.
     */
    groupingKey?: string;
    /**
     * Template for sending a signal to resolve the Incident.
     */
    resolveSignal?: string;
    /**
     * Templates for Slack.
     */
    slack?: outputs.OncallIntegrationTemplatesSlack;
}

export interface OncallIntegrationTemplatesSlack {
    imageUrl?: string;
    message?: string;
    title?: string;
}

export interface OncallRouteMsteams {
    /**
     * Enable notification in MS teams. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * MS teams channel id. Alerts will be directed to this channel in Microsoft teams.
     */
    id?: string;
}

export interface OncallRouteSlack {
    /**
     * Slack channel id. Alerts will be directed to this channel in Slack.
     */
    channelId?: string;
    /**
     * Enable notification in Slack. Defaults to `true`.
     */
    enabled?: boolean;
}

export interface OncallRouteTelegram {
    /**
     * Enable notification in Telegram. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * Telegram channel id. Alerts will be directed to this channel in Telegram.
     */
    id?: string;
}

export interface OncallScheduleSlack {
    /**
     * Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.
     */
    channelId?: string;
    /**
     * Slack user group id. Members of user group will be updated when on-call users change.
     */
    userGroupId?: string;
}

export interface PlaylistItem {
    /**
     * The ID of this resource.
     */
    id: string;
    order: number;
    title: string;
    type?: string;
    value?: string;
}

export interface ReportSchedule {
    /**
     * Custom interval of the report.
     * **Note:** This field is only available when frequency is set to `custom`.
     */
    customInterval?: string;
    /**
     * End time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana.
     */
    endTime?: string;
    /**
     * Frequency of the report. One of `never`, `once`, `hourly`, `daily`, `weekly`, `monthly` or `custom`.
     */
    frequency: string;
    /**
     * Start time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana.
     */
    startTime?: string;
    /**
     * Whether to send the report only on work days. Defaults to `false`.
     */
    workdaysOnly?: boolean;
}

export interface ReportTimeRange {
    /**
     * Start of the time range.
     */
    from?: string;
    /**
     * End of the time range.
     */
    to?: string;
}

export interface RolePermission {
    /**
     * Specific action users granted with the role will be allowed to perform (for example: `users:read`)
     */
    action: string;
    /**
     * Scope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`)
     */
    scope?: string;
}

export interface RuleGroupRule {
    /**
     * Key-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.
     */
    annotations?: {[key: string]: string};
    /**
     * The `refId` of the query node in the `data` field to use as the alert condition.
     */
    condition: string;
    /**
     * A sequence of stages that describe the contents of the rule.
     */
    datas: outputs.RuleGroupRuleData[];
    /**
     * Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, and Alerting. Defaults to `Alerting`.
     */
    execErrState?: string;
    /**
     * The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.
     */
    for?: string;
    /**
     * Key-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.
     */
    labels?: {[key: string]: string};
    /**
     * The name of the alert rule.
     */
    name: string;
    /**
     * Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, and Alerting. Defaults to `NoData`.
     */
    noDataState?: string;
    /**
     * The unique identifier of the alert rule.
     */
    uid: string;
}

export interface RuleGroupRuleData {
    datasourceUid: string;
    model: string;
    queryType?: string;
    refId: string;
    relativeTimeRange: outputs.RuleGroupRuleDataRelativeTimeRange;
}

export interface RuleGroupRuleDataRelativeTimeRange {
    from: number;
    to: number;
}

export interface SyntheticMonitoringCheckSettings {
    /**
     * Settings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).
     */
    dns?: outputs.SyntheticMonitoringCheckSettingsDns;
    /**
     * Settings for HTTP check. The target must be a URL (http or https).
     */
    http?: outputs.SyntheticMonitoringCheckSettingsHttp;
    /**
     * Settings for ping (ICMP) check. The target must be a valid hostname or IP address.
     */
    ping?: outputs.SyntheticMonitoringCheckSettingsPing;
    /**
     * Settings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.
     */
    tcp?: outputs.SyntheticMonitoringCheckSettingsTcp;
    /**
     * Settings for traceroute check. The target must be a valid hostname or IP address
     */
    traceroute?: outputs.SyntheticMonitoringCheckSettingsTraceroute;
}

export interface SyntheticMonitoringCheckSettingsDns {
    ipVersion?: string;
    port?: number;
    protocol?: string;
    recordType?: string;
    server?: string;
    sourceIpAddress?: string;
    validRCodes?: string[];
    validateAdditionalRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr[];
    validateAnswerRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs;
    validateAuthorityRrs?: outputs.SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs;
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAdditionalRr {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAnswerRrs {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsDnsValidateAuthorityRrs {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SyntheticMonitoringCheckSettingsHttp {
    basicAuth?: outputs.SyntheticMonitoringCheckSettingsHttpBasicAuth;
    bearerToken?: string;
    body?: string;
    cacheBustingQueryParamName?: string;
    failIfBodyMatchesRegexps?: string[];
    failIfBodyNotMatchesRegexps?: string[];
    failIfHeaderMatchesRegexps?: outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp[];
    failIfHeaderNotMatchesRegexps?: outputs.SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp[];
    failIfNotSsl?: boolean;
    failIfSsl?: boolean;
    headers?: string[];
    ipVersion?: string;
    method?: string;
    noFollowRedirects?: boolean;
    proxyUrl?: string;
    tlsConfig?: outputs.SyntheticMonitoringCheckSettingsHttpTlsConfig;
    validHttpVersions?: string[];
    validStatusCodes?: number[];
}

export interface SyntheticMonitoringCheckSettingsHttpBasicAuth {
    password: string;
    username: string;
}

export interface SyntheticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp {
    allowMissing?: boolean;
    header: string;
    regexp: string;
}

export interface SyntheticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp {
    allowMissing?: boolean;
    header: string;
    regexp: string;
}

export interface SyntheticMonitoringCheckSettingsHttpTlsConfig {
    caCert?: string;
    clientCert?: string;
    clientKey?: string;
    insecureSkipVerify?: boolean;
    serverName?: string;
}

export interface SyntheticMonitoringCheckSettingsPing {
    dontFragment?: boolean;
    ipVersion?: string;
    payloadSize?: number;
    sourceIpAddress?: string;
}

export interface SyntheticMonitoringCheckSettingsTcp {
    ipVersion?: string;
    queryResponses?: outputs.SyntheticMonitoringCheckSettingsTcpQueryResponse[];
    sourceIpAddress?: string;
    tls?: boolean;
    tlsConfig?: outputs.SyntheticMonitoringCheckSettingsTcpTlsConfig;
}

export interface SyntheticMonitoringCheckSettingsTcpQueryResponse {
    expect: string;
    send: string;
    startTls?: boolean;
}

export interface SyntheticMonitoringCheckSettingsTcpTlsConfig {
    caCert?: string;
    clientCert?: string;
    clientKey?: string;
    insecureSkipVerify?: boolean;
    serverName?: string;
}

export interface SyntheticMonitoringCheckSettingsTraceroute {
    maxHops?: number;
    maxUnknownHops?: number;
    ptrLookup?: boolean;
}

